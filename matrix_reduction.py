# Install necessary libraries
!pip install gmpy2 fpylll

import logging
import numpy as np
import gmpy2
from fpylll import IntegerMatrix, LLL

# Setting up logging for debugging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# SECP256K1 order
order = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141

def modular_inv(a, b):
    """Return the modular inverse of a with respect to b."""
    return int(gmpy2.invert(a, b))

def load_data():
    """Hard-coded values for signature and message hashes."""
    msgs = [
        0xYourMessageHashHere1,  # Replace with the actual message hash (z) from the blockchain
        0xYourMessageHashHere2   # Replace with the actual message hash (z) from the blockchain
    ]
    sigs = [
        (0x39db71a76ec7d70342d14de145b89fa0a76b404574b4ba808642804b1d63afb4, 0x3a6fc51d64cb03a817f9f23626861395eb7cfafddaaeacbb815a18390b855199),  # Signature 1 (r, s)
        (0x22178323234047982875950805124350520409091777216403567012454735277315806448770, 0x55588659104136377467726050079982943955663928290601484880900483243450404406738)   # Signature 2 (r, s)
    ]
    return msgs, sigs

def make_matrix(msgs, sigs, B):
    """Create the lattice basis matrix for the LLL attack."""
    m = len(msgs)
    logger.info("Using %d signatures...", m)
    
    # Initialize the matrix with appropriate size
    matrix = IntegerMatrix(m + 2, m + 2)

    msgn, rn, sn = [msgs[-1], sigs[-1][0], sigs[-1][1]]
    rnsn_inv = rn * modular_inv(sn, order)
    mnsn_inv = msgn * modular_inv(sn, order)

    for i in range(0, m):
        matrix[i, i] = order

    for i in range(0, m):
        x0 = (sigs[i][0] * modular_inv(sigs[i][1], order)) - rnsn_inv
        x1 = (msgs[i] * modular_inv(sigs[i][1], order)) - mnsn_inv
        matrix[m + 0, i] = x0
        matrix[m + 1, i] = x1

    matrix[m + 0, i + 1] = int(2**B) / order
    matrix[m + 1, i + 2] = 2**B

    return matrix

def privkeys_from_reduced_matrix(msgs, sigs, matrix):
    """Extract potential private keys from the reduced matrix."""
    keys = []
    msgn, rn, sn = [msgs[-1], sigs[-1][0], sigs[-1][1]]
    
    for row in matrix:
        potential_nonce_diff = row[0]
        potential_priv_key = (
            (sn * msgs[0])
            - (sigs[0][1] * msgn)
            - (sigs[0][1] * sn * potential_nonce_diff)
        )
        try:
            potential_priv_key *= modular_inv(
                (rn * sigs[0][1]) - (sigs[0][0] * sn), order
            )
            key = potential_priv_key % order
            if key not in keys:
                keys.append(key)
        except Exception as e:
            logger.error("Error calculating private key: %s", str(e))
    return keys

def display_keys(keys):
    """Print out the private keys."""
    for key in keys:
        logger.info("Found private key: %064x", key)

def main():
    B = 128  # Bit length parameter, adjust as needed
    msgs, sigs = load_data()
    matrix = make_matrix(msgs, sigs, B)
    
    # Perform the LLL reduction
    try:
        reduced_matrix = LLL.reduction(matrix)
        keys = privkeys_from_reduced_matrix(msgs, sigs, reduced_matrix)
        display_keys(keys)
    except Exception as e:
        logger.error("Error during LLL reduction: %s", str(e))

if __name__ == "__main__":
    main()
