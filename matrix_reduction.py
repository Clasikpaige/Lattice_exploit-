import logging
import numpy as np
from scipy.linalg import lu
from fpylll import IntegerMatrix, LLL

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# The order of the secp256k1 curve (a large prime number)
order = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F

def modular_inv(a, b):
    """Computes the modular inverse of a modulo b using extended Euclidean algorithm."""
    return pow(a, -1, b)

def make_matrix(msgs, sigs, B):
    """Constructs the matrix to be reduced."""
    m = len(msgs)
    logger.info(f"Using {m} signatures to build the matrix...")

    # Initialize an empty matrix
    matrix = np.zeros((m + 2, m + 2))

    msgn, rn, sn = msgs[-1], sigs[-1][0], sigs[-1][1]
    rnsn_inv = rn * modular_inv(sn, order)
    mnsn_inv = msgn * modular_inv(sn, order)

    for i in range(m):
        matrix[i, i] = order

    for i in range(m):
        x0 = (sigs[i][0] * modular_inv(sigs[i][1], order)) - rnsn_inv
        x1 = (msgs[i] * modular_inv(sigs[i][1], order)) - mnsn_inv
        matrix[m + 0, i] = x0
        matrix[m + 1, i] = x1

    matrix[m + 0, m] = 2**B // order
    matrix[m + 1, m + 1] = 2**B

    return matrix

def privkeys_from_reduced_matrix(msgs, sigs, matrix):
    """Extracts potential private keys from the reduced matrix."""
    keys = []
    msgn, rn, sn = msgs[-1], sigs[-1][0], sigs[-1][1]
    for row in matrix:
        potential_nonce_diff = int(row[0])
        potential_priv_key = (
            (sn * msgs[0])
            - (sigs[0][1] * msgn)
            - (sigs[0][1] * sn * potential_nonce_diff)
        )
        try:
            potential_priv_key *= modular_inv(
                (rn * sigs[0][1]) - (sigs[0][0] * sn), order
            )
            key = potential_priv_key % order
            if key not in keys:
                keys.append(key)
        except Exception as e:
            logger.error(f"Error calculating private key: {e}")
    return keys

def display_keys(keys):
    """Displays the recovered keys."""
    for key in keys:
        logger.info(f"Potential private key: {key:064x}")

def main():
    # Hard-coded values
    B = 256  # Bit length of secp256k1 curve

    # Your actual values (replace placeholders with the correct values)
    msgs = [
        0xede7bf723863ffac69bb751b2d16da1ec21db54ab1ff206f704e0b8252508be2,  # Message hash 1
        0x06ac3ff43a752e75d32ccf41672c4f49072bf0c003ee5ac279a7052f17fbbb56   # Message hash 2
    ]
    sigs = [
        (26169556287747492500740249199257919929143265800899567848279171969158796783540, 26431625678503366673766118647209815071024334423589594528067410121668142911897),  # Signature 1
        (22178323234047982875950805124350520409091777216403567012454735277315806448770, 55588659104136377467726050079982943955663928290601484880900483243450404406738)   # Signature 2
    ]

    matrix = make_matrix(msgs, sigs, B)
    # Converting the matrix to an IntegerMatrix for fpylll
    fpylll_matrix = IntegerMatrix.from_matrix(matrix)

    # Perform LLL reduction
    reduced_matrix = LLL.reduction(fpylll_matrix)
    keys = privkeys_from_reduced_matrix(msgs, sigs, reduced_matrix)

    # Display the results
    display_keys(keys)

if __name__ == "__main__":
    main()
